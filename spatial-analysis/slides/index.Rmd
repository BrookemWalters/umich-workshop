---
title: "Spatial Analysis of US Census Data in R"
subtitle: "Geometries, maps, and methods"  
author: "Kyle Walker"
date: March 11, 2021
output:
  xaringan::moon_reader:
    lib_dir: libs
    css: xaringan-themer.css
    nature:
      highlightStyle: github
      highlightLines: true
      countIncrementalSlides: false
      ratio: 16:9
---

```{r setup, include=FALSE}
options(htmltools.dir.version = FALSE)
options(tigris_use_cache = TRUE)
library(tigris)
library(tmap)
tmap_options(legend.text.size = 1)

knitr::opts_chunk$set(message = FALSE, warning = FALSE, fig.width = 8)
```

```{r xaringan-themer, include=FALSE, warning=FALSE}
library(xaringanthemer)

style_xaringan(
  title_slide_background_color = "#035004",
  text_color = "black",
  header_color = "#035004",
  inverse_background_color = "#035004",
  text_font_family = "Gotham Narrow",
  header_font_family = "Helvetica",
  header_font_weight = "bold",
  link_color = "#1a730f",
  code_inline_color = "#035004"
)
```

## About me

* Associate Professor of Geography at TCU 

* Spatial data science researcher and consultant

* R package developer: tidycensus, tigris, mapboxapi

* Book coming this year: _Analyzing the US Census with R_
  - These workshops are a sneak preview of the book's content!

---

## SSDAN workshop series

* Today: spatial analysis and mapping in R

* Last Thursday (March 4): an introduction to analyzing US Census data with tidycensus 

* Thursday, March 25: working with US Census microdata (PUMS) with R and tidycensus

---

## Today's agenda

* Hour 1: An introduction to Census geometries and the tigris package

* Hour 2: Mapping Census data in R

* Hour 3: Spatial analysis of Census data with the sf package

---
class: middle, center, inverse

## Part 1: An introduction to Census geometries and the tigris package

---

## US Census Geography

<img src=img/census_diagram.png style="width: 500px">

.footnote[Source: [US Census Bureau](https://www2.census.gov/geo/pdfs/reference/geodiagram.pdf)]

---

## Census TIGER/Line shapefiles

{info here}

---

## A typical GIS workflow

{image from QGIS here}

---

## The __tigris__ R package

.pull-left[
<img src="https://raw.githubusercontent.com/walkerke/tigris/master/tools/readme/tigris_sticker.png" style="width: 400px">
]

.pull-right[

* R interface to the US Census Bureau's TIGER/Line shapefile FTP server

* No API key necessary - just install the package and start using Census shapefiles in R!

]

---

## Basic usage of tigris

* To use tigris, call a function that corresponds to the Census geography you want, optionally by `state` or `county`, when appropriate

```{r basic-usage}
or_counties <- counties(state = "OR")

or_counties
```
---

```{r basic-plot}
plot(or_counties$geometry)
```

---

## The __sf__ package and simple feature geometry

.pull-left[

<img src="https://user-images.githubusercontent.com/520851/34887433-ce1d130e-f7c6-11e7-83fc-d60ad4fae6bd.gif" style="width: 300px">

]

.pull-right[

* The sf package implements a _simple features data model_ for vector spatial data in R

* Vector geometries: _points_, _lines_, and _polygons_ stored in a list-column of a data frame

* Allows for tidy spatial data analysis (coming in hour 3!)

]

---

## Datasets available in tigris

* __Legal entities__: units that have legal significance in the US (e.g. states, counties)

* __Statistical entities__: units that are used to tabulate Census data but do not have legal standing (e.g. Census tracts or block groups)

* __Geographic features__: other geographic datasets provided by the Census Bureau that are not used for demographic tabulation (e.g. roads, water)

---

## Example: statistical entities

```{r benton-tracts}
benton_tracts <- tracts(state = "OR", county = "Benton")

plot(benton_tracts$geometry)
```

---

## Example: geographic features

```{r benton-roads}
benton_roads <- roads(state = "OR", county = "Benton")

plot(benton_roads$geometry)
```

---

## Example: geographic features

```{r dc-landmarks}
dc_landmarks <- landmarks("DC", type = "point")

plot(dc_landmarks$geometry)
```


---

## How tigris works

When you call a tigris function, it does the following: 

* _Downloads_ your data from the US Census Bureau website; 

* _Stores_ your data in a temporary directory by default; 

* _Loads_ your data into R as a simple features object using `sf::st_read()`

* Recommended option: use `options(tigris_use_cache = TRUE)` to cache downloaded shapefiles and prevent having to re-download every time you use them

---
class: middle, center, inverse

## tigris features and options

---

## Cartographic boundary shapefiles

.pull-left[
* Question I've received over the years: "Why does Michigan look so weird?"

* The core TIGER/Line shapefiles include _water area_ that belongs to US states and counties

]

.pull-right[
```{r michigan-tiger}
mi_counties <- counties("MI")

plot(mi_counties$geometry)
```
]


---

## Cartographic boundary shapefiles


.pull-left[
* Use the argument `cb = TRUE` to obtain a _cartographic boundary shapefile_ pre-clipped to the US shoreline

* For some geographies, highly generalized (1:5 million and 1:20 million) shapefiles are available with the `resolution` argument
]

.pull-right[
```{r michigan-cb}
mi_counties_cb <- counties("MI", cb = TRUE)

plot(mi_counties_cb$geometry)
```
]

---

## Understanding yearly differences in TIGER/Line files

* Whereas legal entities change shape very rarely (but they do change!), statistical entities change with every decennial Census

* tigris fetches Census shapefiles from 1990 up through 2020

```{r get-yearly-data}
tarrant90 <- tracts("TX", "Tarrant", cb = TRUE, year = 1990)
tarrant00 <- tracts("TX", "Tarrant", cb = TRUE, year = 2000)
tarrant10 <- tracts("TX", "Tarrant", cb = TRUE, year = 2010)
# Cartographic boundary files not yet released for 2020
tarrant20 <- tracts("TX", "Tarrant", year = 2020)

```
---

```{r plot-yearly-data}
par(mfrow = c(2, 2))

plot(tarrant90$geometry, main = "1990")
plot(tarrant00$geometry, main = "2000")
plot(tarrant10$geometry, main = "2010")
plot(tarrant20$geometry, main = "2020")


```

---

## Interactive viewing of data with __mapview__

```{r mapview, eval = FALSE}
library(mapview)

mapview(tarrant20)
```

---

## Comparing shapes interactively

```{r sync, eval = FALSE}
library(leafsync)

sync(mapview(tarrant90), mapview(tarrant20))

```

---

## Combining spatial datasets

```{r combine-bgs}
library(tidyverse)

state_codes <- c(state.abb, "DC")

us_bgs <- map_df(state_codes, ~block_groups(state = .x, cb = TRUE))

glimpse(us_bgs)
```
---

## US Census shapefiles and coordinate reference systems

* _Coordinate reference system_ (CRS): how coordinates in your spatial data are referenced to the Earth's surface

* Distinction: _geographic coordinate systems_ (longitude/latitude) and _projected coordinate systems_ (planar, commonly measured in meters or US feet)

* CRS used by Census shapefiles: North American Datum of 1983 (EPSG code 4269)

---

```{r check-crs}
library(sf)

fl_counties <- counties("FL", cb = TRUE)

st_crs(fl_counties)
```
---

## Choosing a coordinate reference system

* __crsuggest__ my _developmental_ R package for helping choose the right coordinate system transformation

* To install: `remotes::install_github("walkerke/crsuggest")`

* Two core functions: `suggest_crs()` for a table of CRS recommendations; `suggest_top_crs()` for a quick best match


---

## Choosing a coordinate reference system

```{r suggest-crs}
library(crsuggest)

fl_crs <- suggest_crs(fl_counties)

glimpse(fl_crs)
```

---

## CRS transformations

* Use the `st_transform()` function in the sf package to perform coordinate reference system transformations with the appropriate EPSG code

```{r transform-crs}
fl_projected <- st_transform(fl_counties, crs = 3086)

head(fl_projected)
```

---

## Part 1 exercises

{exercises here}

---
class: middle, center, inverse

## Part 2: Mapping US Census data in R

---

## Typical Census GIS workflows

.pull-left[

Traditionally, getting "spatial" Census data requires: 

* Fetching shapefiles from the Census website;

* Downloading a CSV of data, cleaning/formatting it;

* Loading geometries and data into your GIS of choice;

* Aligning key fields in your GIS and joining your data

]

.pull-right[

{image from QGIS here}


]

---

## Geometry in tidycensus

* tidycensus takes care of this entire process with the argument `geometry = TRUE`

```{r tidycensus-geometry}
library(tidycensus)
options(tigris_use_cache = TRUE)

dc_income <- get_acs(geography = "tract", 
                     variables = c(hhincome = "B19013_001"), 
                     state = "DC", 
                     geometry = TRUE)

```

---

```{r show-geometry}
dc_income
```

---

## Basic mapping with base plotting

```{r plot-geometry}
plot(dc_income["estimate"])
```

---

## Basic mapping with ggplot2

* `geom_sf()`: ggplot2 method to use simple features in your data visualization workflows

```{r geom-sf}
library(tidyverse)

dc_map <- ggplot(dc_income, aes(fill = estimate)) + 
  geom_sf()
```

---

```{r plot-geom-sf}
dc_map
```

---
class: middle, center, inverse

## Mapping Census data with tmap

---

## The tmap package

.pull-left[

<img src="https://user-images.githubusercontent.com/2444081/106523217-12c12880-64e1-11eb-8d55-01442d535400.png" style="width: 350px">

]

.pull-right[

* Comprehensive package for thematic mapping in R

* ggplot2-like syntax, but designed in a way to feel friendly to GIS cartographers coming to R for mapping

]

---

## Example data

* Our example: comparing the distributions of racial and ethnic groups in Hennepin County, Minnesota (Minneapolis)

```{r get-hennepin-data}
hennepin_race <- get_acs(
  geography = "tract",
  state = "MN",
  county = "Hennepin",
  variables = c(White = "B03002_003",
                Black = "B03002_004",
                Native = "B03002_005",
                Asian = "B03002_006",
                Hispanic = "B03002_012"),
  summary_var = "B03002_001",
  geometry = TRUE
) %>%
  mutate(percent = 100 * (estimate / summary_est))
```

---

```{r glimpse-hennepin-data}
glimpse(hennepin_race)
```
---

## Basic plotting with tmap

.pull-left[

* `tm_shape()` initializes the shape; `tm_polygons()` shows the polygons for quick display

```{r polygons-code, eval = FALSE}
library(tmap)

hennepin_black <- filter(hennepin_race, 
                         variable == "Black")

tm_shape(hennepin_black) + 
  tm_polygons() 
```

]

.pull-right[

```{r polygons-map, echo = FALSE}
library(tmap)

hennepin_black <- filter(hennepin_race, 
                         variable == "Black")

tm_shape(hennepin_black) + 
  tm_polygons() 
```

]



---

## Choropleth mapping with tmap

.pull-left[

* _Choropleth maps_ show statistical variation through color or shading of areas

* They generally should be used with _normalized data_ such as rates or percentages, not counts

```{r choropleth-code, eval = FALSE}
tm_shape(hennepin_black) + 
  tm_polygons(col = "percent")
```

]

.pull-right[

```{r choropleth-show, echo = FALSE}
tm_shape(hennepin_black) + 
  tm_polygons(col = "percent")
```

]


---

## Modifying choropleth options

* Color palettes can be modified with the `palette` parameter, which accepts ColorBrewer and viridis palettes

* If you've mapped with GIS software before, the `style` parameter implements various breaks methods, including `"equal"`, `"quantile"` and `"jenks"`

---

.pull-left[

```{r custom-choropleth-code, eval = FALSE}
tm_shape(hennepin_black, 
         projection = sf::st_crs(26915)) + 
  tm_polygons(col = "percent",
          style = "quantile",
          n = 7,
          palette = "Purples",
          title = "ACS estimate") + 
  tm_layout(title = "Percent Black population\nby Census tract",
            frame = FALSE,
            legend.outside = TRUE)
```

]

.pull-right[

```{r custom-choropleth-show, echo = FALSE}
tm_shape(hennepin_black, 
         projection = sf::st_crs(26915)) + 
  tm_polygons(col = "percent",
          style = "quantile",
          n = 7,
          palette = "Purples",
          title = "ACS estimate") + 
  tm_layout(title = "Percent Black population\nby Census tract",
            frame = FALSE,
            legend.outside = TRUE)
```

]



---

## tmap choropleth tips and tricks

* Use `tmaptools::palette_explorer()` to interactively browse color options

* Use the option `tm_layout(legend.hist = TRUE)` to display the distribution of data values among classes

---

.pull-left[

```{r jenks-code, eval = FALSE}
tm_shape(hennepin_black, 
         projection = sf::st_crs(26915)) + 
  tm_polygons(col = "percent",
          style = "jenks",
          n = 7,
          palette = "viridis",
          title = "ACS estimate",
          legend.hist = TRUE) + 
  tm_layout(title = "Percent Black population\nby Census tract",
            frame = FALSE,
            legend.outside = TRUE)
```

]

.pull-right[

```{r jenks-show, echo = FALSE}
tm_shape(hennepin_black, 
         projection = sf::st_crs(26915)) + 
  tm_polygons(col = "percent",
          style = "jenks",
          n = 7,
          palette = "viridis",
          title = "ACS estimate",
          legend.hist = TRUE) + 
  tm_layout(title = "Percent Black population\nby Census tract",
            frame = FALSE,
            legend.outside = TRUE)
```

]

---

## Graduated symbol maps

* Graduated symbols: using _size_ of a symbol to represent statistical variation on a map

* Implemented in tmap with `tm_bubbles()`

```{r bubbles-code}
symbol_map <- tm_shape(hennepin_black) + 
  tm_polygons() + 
  tm_bubbles(size = "estimate", alpha = 0.5, 
             col = "navy")
```

---

```{r bubbles-map}
symbol_map
```

---

## Faceted mapping

* `tm_facets()` allows for comparative small multiples maps.  It works well with long-form spatial data returned by tidycensus

```{r facet-map-code}
facet_map <- tm_shape(hennepin_race,
         projection = sf::st_crs(26915)) + 
  tm_facets(by = "variable", scale.factor = 4) + 
  tm_fill(col = "percent",
          style = "quantile",
          n = 7,
          palette = "Blues")
```

---

```{r facet-map}
facet_map
```

---

## Advanced example: dot-density mapping

.pull-left[

* Dot-density maps scatter dots relative to data values, and are good for showing within-polygon diversity

* To generate points for dot-density mapping, points should be proportionally sampled in polygons relative to data values then randomized with `slice_sample()`

]

.pull-right[

```{r generate-dots, echo = FALSE, eval = FALSE}
groups <- unique(hennepin_race$variable)

hennepin_dots <- map_df(groups, ~{
  hennepin_race %>%
    filter(variable == .x) %>%
    st_transform(26915) %>%
    mutate(est50 = as.integer(estimate / 50)) %>%
    st_sample(size = .$est50, exact = TRUE) %>%
    st_sf() %>%
    mutate(group = .x)
}) %>%
  slice_sample(prop = 1)
```

]


---

## Advanced example: dot-density mapping

```{r plot-dots, eval = FALSE}
tm_shape(hennepin_dots) +
  tm_dots(col = "group", palette = "Set1", size = 0.005)
```

---

## Mapping the entire US with `shift_geo`

```{r shift-geo}
us_median_age <- get_acs(geography = "state",
                         variables = "B01002_001",
                         year = 2019,
                         survey = "acs1",
                         geometry = TRUE,
                         shift_geo = TRUE)

us_median_age
```
---

## Mapping the entire US with `shift_geo`

```{r show-shift-geo}
tm_shape(us_median_age) + 
  tm_polygons()
```

---

## Mapping the entire US with `shift_geo`

```{r style-shift-geo}
tm_shape(us_median_age) + 
  tm_polygons(col = "estimate", palette = "RdPu", title = "Median age") + 
  tm_layout(legend.outside = TRUE)
```

## Interactive mapping

{a few slides here}

---

## What if I still want to use a GIS?

* No problem! Write out your data to a shapefile/GeoJSON/GeoPackage with `sf::st_write()` and load into your GIS of choice

* Recommendation: use `output = "wide"` for multi-variable datasets (easier to use in a desktop GIS)

```{r write-shp, eval = FALSE}
library(sf)

st_write(dc_income, "data/dc_income.shp")
```


---

## Exercises

{fill in here}

---
class: middle, center, inverse

## Spatial analysis of US Census data with the sf package

---

## sf: a tidy data model for spatial analysis



## "Tidy" spatial analysis

{general discussion here}

---

## Spatial overlay

{info here}

---

## Methods for spatial overlay

{info here}

---

## Spatial predicates

{examples here}

---
class: middle, center, inverse

## Spatial joins and group-wise spatial analysis

---

## Spatial joins

{info here}

---

## Distance and proximity analysis

{series of slides here}

---

## Exploratory spatial data analysis

{info here}

---

## Spatial clustering

{info here}







